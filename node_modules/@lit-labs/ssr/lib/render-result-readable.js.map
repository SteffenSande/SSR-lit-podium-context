{"version":3,"file":"render-result-readable.js","sourceRoot":"","sources":["../src/lib/render-result-readable.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAEH,OAAO,EAAC,QAAQ,EAAC,MAAM,QAAQ,CAAC;AAKhC;;GAEG;AACH,MAAM,OAAO,oBAAqB,SAAQ,QAAQ;IAYhD,YAAY,MAAoB;QAC9B,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;QACtB,IAAI,CAAC,UAAU,GAAG,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;IACtD,CAAC;IAEQ,KAAK,CAAC,KAAK,CAAC,KAAa;QAChC,yEAAyE;QACzE,mEAAmE;QACnE,sCAAsC;QACtC,uEAAuE;QACvE,oCAAoC;QACpC,mEAAmE;QACnE,iBAAiB;QACjB,EAAE;QACF,mEAAmE;QACnE,8BAA8B;QAC9B,EAAE;QACF,6CAA6C;QAC7C,oEAAoE;QACpE,qEAAqE;QACrE,mCAAmC;QACnC,yEAAyE;QACzE,sEAAsE;QACtE,4EAA4E;QAC5E,yDAAyD;QACzD,sCAAsC;QACtC,EAAE;QACF,sEAAsE;QACtE,sEAAsE;QACtE,0CAA0C;QAE1C,2BAA2B;QAC3B,IAAI,QAAQ,GAAG,IAAI,CAAC,UAAU,CAAC,GAAG,EAAE,CAAC;QAErC,OAAO,QAAQ,KAAK,SAAS,EAAE;YAC7B,MAAM,IAAI,GAAG,QAAQ,CAAC,IAAI,EAAE,CAAC;YAC7B,IAAI,IAAI,CAAC,IAAI,KAAK,IAAI,EAAE;gBACtB,6BAA6B;gBAC7B,QAAQ,GAAG,IAAI,CAAC,UAAU,CAAC,GAAG,EAAE,CAAC;gBACjC,SAAS;aACV;YAED,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;YAEzB,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;gBAC7B,IAAI,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,KAAK,EAAE;oBAC9B,gEAAgE;oBAChE,mCAAmC;oBACnC,OAAO;iBACR;aACF;iBAAM;gBACL,oBAAoB;gBACpB,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;gBAC/B,QAAQ,GAAG,CAAC,MAAM,KAAK,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC,EAA0B,CAAC;aACrE;SACF;QACD,iCAAiC;QACjC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAClB,CAAC;CACF","sourcesContent":["/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {Readable} from 'stream';\nimport {RenderResult} from './render-result.js';\n\ntype RenderResultIterator = Iterator<string | Promise<RenderResult>>;\n\n/**\n * A Readable that reads from a RenderResult.\n */\nexport class RenderResultReadable extends Readable {\n  private _result: RenderResult;\n\n  /**\n   * A stack of open iterators.\n   *\n   * We need to keep this as instance state because we can pause and resume\n   * reading values at any time and can't guarantee to run iterators to\n   * completion in any one loop.\n   */\n  private _iterators: Array<RenderResultIterator>;\n\n  constructor(result: RenderResult) {\n    super();\n    this._result = result;\n    this._iterators = [this._result[Symbol.iterator]()];\n  }\n\n  override async _read(_size: number) {\n    // This implementation reads values from the RenderResult and pushes them\n    // into the base class's Readable implementation. It tries to be as\n    // efficient as possible, which means:\n    //   1. Avoid microtasks and Promise allocations. Read and write values\n    //      synchronously when possible.\n    //   2. Write as many values to the Readable per call to _read() as\n    //      possible.\n    //\n    // To do this correctly we must adhere to the Readable contract for\n    // _read(), which states that:\n    //\n    // - The size parameter can be safely ignored\n    // - _read() should call `this.push()` as many times as it can until\n    //   `this.push()` returns false, which means the underlying Readable\n    //   does not want any more values.\n    // - `this._read()` should not be called by the underlying Readable until\n    //   after this.push() has returned false, so we can wait on a Promise\n    //   and call _read() when it resolves to continue without a race condition.\n    //   (We try to verify this with the this._waiting field)\n    // - `this.push(null)` ends the stream\n    //\n    // This means that we cannot use for/of loops to iterate on the render\n    // result, because we must be able to return in the middle of the loop\n    // and resume on the next call to _read().\n\n    // Get the current iterator\n    let iterator = this._iterators.pop();\n\n    while (iterator !== undefined) {\n      const next = iterator.next();\n      if (next.done === true) {\n        // Restore the outer iterator\n        iterator = this._iterators.pop();\n        continue;\n      }\n\n      const value = next.value;\n\n      if (typeof value === 'string') {\n        if (this.push(value) === false) {\n          // The consumer doesn't want any more values. Return for now and\n          // we may get a new call to _read()\n          return;\n        }\n      } else {\n        // Must be a Promise\n        this._iterators.push(iterator);\n        iterator = (await value)[Symbol.iterator]() as RenderResultIterator;\n      }\n    }\n    // Pushing `null` ends the stream\n    this.push(null);\n  }\n}\n"]}