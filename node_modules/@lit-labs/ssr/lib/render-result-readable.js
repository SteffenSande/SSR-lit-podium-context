/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
import { Readable } from 'stream';
/**
 * A Readable that reads from a RenderResult.
 */
export class RenderResultReadable extends Readable {
    constructor(result) {
        super();
        this._result = result;
        this._iterators = [this._result[Symbol.iterator]()];
    }
    async _read(_size) {
        // This implementation reads values from the RenderResult and pushes them
        // into the base class's Readable implementation. It tries to be as
        // efficient as possible, which means:
        //   1. Avoid microtasks and Promise allocations. Read and write values
        //      synchronously when possible.
        //   2. Write as many values to the Readable per call to _read() as
        //      possible.
        //
        // To do this correctly we must adhere to the Readable contract for
        // _read(), which states that:
        //
        // - The size parameter can be safely ignored
        // - _read() should call `this.push()` as many times as it can until
        //   `this.push()` returns false, which means the underlying Readable
        //   does not want any more values.
        // - `this._read()` should not be called by the underlying Readable until
        //   after this.push() has returned false, so we can wait on a Promise
        //   and call _read() when it resolves to continue without a race condition.
        //   (We try to verify this with the this._waiting field)
        // - `this.push(null)` ends the stream
        //
        // This means that we cannot use for/of loops to iterate on the render
        // result, because we must be able to return in the middle of the loop
        // and resume on the next call to _read().
        // Get the current iterator
        let iterator = this._iterators.pop();
        while (iterator !== undefined) {
            const next = iterator.next();
            if (next.done === true) {
                // Restore the outer iterator
                iterator = this._iterators.pop();
                continue;
            }
            const value = next.value;
            if (typeof value === 'string') {
                if (this.push(value) === false) {
                    // The consumer doesn't want any more values. Return for now and
                    // we may get a new call to _read()
                    return;
                }
            }
            else {
                // Must be a Promise
                this._iterators.push(iterator);
                iterator = (await value)[Symbol.iterator]();
            }
        }
        // Pushing `null` ends the stream
        this.push(null);
    }
}
//# sourceMappingURL=render-result-readable.js.map