File Resolving Architecture
===========================

File path resolver -> resolves known directories and files into an object

```json
{
    "content": { path: "./content.ts", exists: true },
    "fallback": { path: "", exists: false },
    "build": { path: "./build.ts", exists: true },
    "scripts": { path: "", exists: false },
    "lazy": { path: "", exists: false },
    "config/common": { path: "./common/en.json", exists: true },
    "schemas/content": { path: "./schemas/content.json", exists: true },
    "locale/en": { path: "./locale/en.json", exists: true },
    "locale/no": { path: "./locale/no.json", exists: true },
}
```

handles typescript and js switching
needs to have some form of handling of non existent file handling eg. returns `{ exists: false }`
AND some form of invalidator for dev
A standard resolving interface should be provided for use in the codebase

```js
fastify.register(resolvePlugin, async (fastify, opts) => {
    const pathObject = await buildPathsObjectSomehow(opts.cwd);

    // method for pure file resolution
    fastify.decorate('resolve', async function resolve(handle) {
        if (pathObject[handle] && pathObject[handle].exists) return pathObject[handle].path;
        return false;
    });

    fastify.decorate('import', async function fileImport(handle) {
        // get the file path info
        const file = (pathObject[handle] && pathObject[handle].exists) ? pathObject[handle].path : { exists: false };

        // if dirty and in development mode, we need to reimport
        if (opts.development && file.dirty) {
            const importedFile = (await import(`${file.path}?${Date.now()}`)).default;
            delete file.dirty;
            return importedFile;
        }

        // otherwise, we just import the file
        return (await import(file.path)).default;
    });

    // mark files as dirty so import will know to reimport
    fastify.decorate('dirty', async function dirtyFile(handle) {
        if (!pathObject[handle]) pathObject[handle] = await resolveFilePathOnDiskSomehow();
        // if file wasn't deleted
        if (pathObject[handle]) {
            pathObject[handle].dirty = true;
        }
    });

    // chokidar can ping this url to mark a file as changed, created or deleted
    fastify.get("/dev/resolve/dirty", (request, reply) => {
        fastify.dirty(request.query.handle);
        reply.send("ok");
    })
})

const path = await resolve('content');
```

